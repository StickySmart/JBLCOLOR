<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>pH-Auswertung mit Markeranzeige (BMUT)</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 1em; background: #f5f5f5; }
    canvas { border: 1px solid #000; margin-top: 1em; max-width: 100%; height: auto; }
    .output { margin-top: 1em; }
    button { margin-top: 1em; padding: 0.5em 1em; font-size: 1em; }
    #log { margin-top: 1em; white-space: pre-line; background: #fff; padding: 1em; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h2>pH-Auswertung mit Marker und Referenzautomatik</h2>

  <p><strong>1. Referenzbild hochladen:</strong></p>
  <input type="file" id="refUpload" accept="image/*">
  <canvas id="refCanvas"></canvas>

  <p><strong>2. Testbild hochladen und Farbe klicken:</strong></p>
  <input type="file" id="testUpload" accept="image/*">
  <canvas id="testCanvas"></canvas>

  <div class="output">
    <p><strong>RGB:</strong> <span id="rgb">---</span></p>
    <p><strong>HEX:</strong> <span id="hex">---</span></p>
    <p><strong>Interpolierter pH-Wert:</strong> <span id="interpolated">---</span></p>
    <button id="saveButton">Messung speichern</button>
    <button id="exportButton">CSV herunterladen</button>
    <div id="log"></div>
  </div>

<script>
let refColors = [];
let lastPH = null;
const csvData = [];

function drawAndExtractReference(canvas, ctx, img) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  refColors = [];
  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;

  if (canvas.width >= canvas.height) {
    const y = canvas.height / 2;
    for (let i = 0; i < 14; i++) {
      const x = (i + 0.5) * canvas.width / 14;
      const data = ctx.getImageData(x, y, 1, 1).data;
      refColors.push({ value: i + 1, rgb: [data[0], data[1], data[2]] });
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.stroke();
    }
  } else {
    const x = canvas.width / 2;
    for (let i = 0; i < 14; i++) {
      const y = (i + 0.5) * canvas.height / 14;
      const data = ctx.getImageData(x, y, 1, 1).data;
      refColors.push({ value: i + 1, rgb: [data[0], data[1], data[2]] });
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.stroke();
    }
  }
}

function loadImage(fileInput, canvasId, drawCallback) {
  const file = fileInput.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function (event) {
    const img = new Image();
    img.onload = function () {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      const scale = Math.min(800 / img.width, 800 / img.height, 1);
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      drawCallback(canvas, ctx, img);
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
}

document.getElementById("refUpload").addEventListener("change", () => {
  loadImage(document.getElementById("refUpload"), "refCanvas", drawAndExtractReference);
});

document.getElementById("testUpload").addEventListener("change", () => {
  loadImage(document.getElementById("testUpload"), "testCanvas", (canvas, ctx, img) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  });
});

document.getElementById("testCanvas").addEventListener("click", function (e) {
  const canvas = document.getElementById("testCanvas");
  const ctx = canvas.getContext("2d");
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const pixel = ctx.getImageData(x, y, 1, 1).data;
  const rgb = [pixel[0], pixel[1], pixel[2]];
  document.getElementById("rgb").textContent = rgb.join(", ");
  document.getElementById("hex").textContent = rgbToHex(...rgb);
  ctx.beginPath();
  ctx.arc(x, y, 5, 0, 2 * Math.PI);
  ctx.strokeStyle = "blue";
  ctx.stroke();
  const interpolated = interpolatePH(rgb);
  document.getElementById("interpolated").textContent = `pH ≈ ${interpolated.toFixed(2)}`;
  lastPH = interpolated.toFixed(2);
});

function rgbToHex(r, g, b) {
  return "#" + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
}

function colorDistance(c1, c2) {
  return Math.sqrt(c1.reduce((acc, val, i) => acc + (val - c2[i]) ** 2, 0));
}

function interpolatePH(rgb) {
  if (refColors.length < 2) return 0;
  const sorted = refColors.slice().sort((a, b) => a.value - b.value);
  let bestPair = null;
  let minDist = Infinity;
  for (let i = 0; i < sorted.length - 1; i++) {
    const d1 = colorDistance(rgb, sorted[i].rgb);
    const d2 = colorDistance(rgb, sorted[i + 1].rgb);
    const sum = d1 + d2;
    if (sum < minDist) {
      minDist = sum;
      bestPair = [sorted[i], sorted[i + 1]];
    }
  }
  if (!bestPair) return sorted[0].value;
  const [a, b] = bestPair;
  const d1 = colorDistance(rgb, a.rgb);
  const d2 = colorDistance(rgb, b.rgb);
  const t = d2 / (d1 + d2);
  return a.value * t + b.value * (1 - t);
}

document.getElementById("saveButton").addEventListener("click", () => {
  if (!lastPH) return;
  const now = new Date();
  const timestamp = now.toLocaleString();
  csvData.push([timestamp, lastPH]);
  document.getElementById("log").textContent += `${timestamp} | pH ≈ ${lastPH}
`;
});

document.getElementById("exportButton").addEventListener("click", () => {
  const rows = [["Datum/Uhrzeit", "pH-Wert"], ...csvData];
  const csv = rows.map(e => e.join(",")).join("\n");
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.setAttribute("href", url);
  link.setAttribute("download", "ph_messprotokoll.csv");
  link.click();
});
</script>
</body>
</html>
